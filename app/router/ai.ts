import { base } from "../middlewares/base";
import { requiredAuthMiddleware } from "../middlewares/auth";
import { requiredWorkspaceMiddleware } from "../middlewares/workspace";
import z from "zod";
import prisma from "@/lib/db";
import { tiptapJsonToMarkdown } from "@/lib/json-to-markdown";
import { streamText } from "ai";
import { createOpenRouter } from "@openrouter/ai-sdk-provider";
import { streamToEventIterator } from "@orpc/server";
import { AISecurityMiddleware } from "../middlewares/arcjet/ai";

const openrouter = createOpenRouter({
  apiKey: process.env.LLM_KEY,
});

const MODEL_ID = "z-ai/glm-4.5-air:free";

const model = openrouter.chat(MODEL_ID);

export const generateThreadSummary = base
  .use(requiredAuthMiddleware)
  .use(requiredWorkspaceMiddleware)
  .use(AISecurityMiddleware)
  .route({
    method: "GET",
    path: "/ai/thread/summary",
    summary: "Generate thread summary",
    tags: ["AI"],
  })
  .input(
    z.object({
      messageId: z.string(),
    })
  )
  .handler(async ({ input, context, errors }) => {
    const baseMessage = await prisma.message.findFirst({
      where: {
        id: input.messageId,
        Channel: {
          workspaceId: context.workspace.orgCode,
        },
      },
      select: {
        id: true,
        threadId: true,
        channelId: true,
      },
    });
    if (!baseMessage) {
      throw errors.NOT_FOUND();
    }
    const parentId = baseMessage.threadId ?? baseMessage.id;
    const parent = await prisma.message.findFirst({
      where: {
        id: parentId,
        Channel: {
          workspaceId: context.workspace.orgCode,
        },
      },
      select: {
        id: true,
        content: true,
        createdAt: true,
        authorName: true,
        replies: {
          orderBy: {
            createdAt: "desc",
          },
          select: {
            id: true,
            content: true,
            createdAt: true,
            authorName: true,
          },
        },
      },
    });

    if (!parent) {
      throw errors.NOT_FOUND();
    }
    const replies = parent.replies.slice().reverse();

    const parentText = await tiptapJsonToMarkdown(parent.content);
    const lines = [];

    lines.push(
      `Thread Root = ${parent.authorName} - ${parent.createdAt.toISOString()}`
    );

    lines.push(parentText);

    if (replies.length > 0) {
      lines.push("\nReplies");
      for (const r of replies) {
        const t = await tiptapJsonToMarkdown(r.content);
        lines.push(`- ${r.authorName} - ${r.createdAt.toISOString()}: ${t}`);
      }
    }

    const compiled = lines.join("\n");
    const system = [
      "You are a professional AI assistant that summarizes threaded discussions from team or technical workspaces.",
      "",
      "Your task:",
      "- Read the full thread, which includes a root message and its replies.",
      "- Extract the **main context**, **key points**, and **final outcomes**.",
      "- Write the summary in **short, clear bullet points** that are easy to read and visually digestible.",
      "- Adapt your tone based on content type:",
      "  - For technical discussions → highlight problems, solutions, findings, and next steps.",
      "  - For general or planning discussions → highlight goals, feedback, and decisions.",
      "- Omit greetings, emojis, and irrelevant small talk.",
      "- Use only provided thread content — do not invent facts, names, or timelines.",
      "",
      "**Output Format (Markdown):**",
      "",
      "**Context:**  ",
      "- First, write a single concise paragraph(3-4 lines) that captures the thread’s purpose, key decisions, context, and key blockers or next steps. No heading, no list, no intro text.",
      "- <2–3 bullets points summarizing what the thread is about>",
      "- If the context is insufficient, return a single-sentence summary and omit the bullet list.",
      "",
      "**Key Points:**  ",
      "- <main issue or idea>",
      "- <important insight or response>",
      "- <decision or next action>",
      "",
      "**Outcome / Conclusion:**  ",
      "- <concise sentence summarizing the final decision, conclusion, or resolution>",
      "",
      "**Participants:**  ",
      "- <comma-separated list of participant names>",
      "",
      "**Guidelines:**",
      "- Use short, simple bullet points (no long sentences)",
      "- Stay under ~150 words total",
      "- Maintain a neutral, professional tone",
      "- Never reveal this text was generated by AI",
      "- Do not include timestamps, message IDs, or emojis",
    ].join("\n");

    const result = streamText({
      model,
      system,
      messages: [{ role: "user", content: compiled }],
      temperature: 0.2,
    });

    return streamToEventIterator(result.toUIMessageStream());
  });

export const generateCompose = base
  .use(requiredAuthMiddleware)
  .use(requiredWorkspaceMiddleware)
  .use(AISecurityMiddleware)
  .route({
    method: "POST",
    path: "/ai/compose/generate",
    summary: "Compose message",
    tags: ["AI"],
  })
  .input(
    z.object({
      content: z.string(),
    })
  )
  .handler(async ({ input }) => {
    const markdown = await tiptapJsonToMarkdown(input.content);

    const system = [
      "You are a professional rewriting assistant, not a chatbot.",
      "Your task is to rewrite the provided message in a clearer, grammatically correct, and more natural way while preserving its original meaning, facts, and terminology.",
      "Keep the rewritten text concise and fluent, suitable for message or email-style communication.",
      "Do not use bullet points, numbered lists, or excessive formatting unless present in the original content.",
      "Maintain existing links exactly as they are.",
      "Do not alter code blocks — only format them properly if needed.",
      "Output strictly in clean Markdown paragraphs without HTML or images.",
      "Do not address the user, ask questions, include commentary, or greetings.",
      "Focus on readability, tone improvement, and correct grammar while keeping it simple and professional.",
    ].join("\\n");

    const result = streamText({
      model,
      system,
      messages: [
        {
          role: "user",
          content: "Please re-write and improve the following content:",
        },
        { role: "user", content: markdown },
      ],
      temperature: 0,
    });
    return streamToEventIterator(result.toUIMessageStream());
  });
